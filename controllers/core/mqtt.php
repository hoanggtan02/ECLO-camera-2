<?php

// File: persistent_listener.php
// Ch·∫°y file n√†y b·∫±ng Supervisor ho·∫∑c Docker ƒë·ªÉ ƒë·∫£m b·∫£o ho·∫°t ƒë·ªông 24/7

error_log("Kh·ªüi ƒë·ªông MQTT Listener...");
error_log("Script is running as user: " . get_current_user());

require __DIR__ . '/../../vendor/autoload.php';

use PhpMqtt\Client\MqttClient;
use PhpMqtt\Client\ConnectionSettings;
use Medoo\Medoo;
use Predis\Client as RedisClient;

// ===================================================================
// == HELPER FUNCTIONS (C√ÅC H√ÄM H·ªñ TR·ª¢) ==
// ===================================================================

/**
 * G·ª≠i m·ªôt tin nh·∫Øn ƒë·∫øn MQTT Broker.
 * @param array $env M·∫£ng ch·ª©a c·∫•u h√¨nh t·ª´ file .env
 * @param string $topic Topic ƒë·ªÉ g·ª≠i tin nh·∫Øn
 * @param array $payload M·∫£ng d·ªØ li·ªáu c·ªßa tin nh·∫Øn
 * @return bool True n·∫øu th√†nh c√¥ng, False n·∫øu th·∫•t b·∫°i
 */
function publishMqttMessage(array $env, string $topic, array $payload): bool
{
    $mqttServer = $env['MQTT_HOST'] ?? 'mqtt.ellm.io';
    $mqttPort = (int)($env['MQTT_PORT_TCP'] ?? 1883);
    $mqttUsername = $env['MQTT_USERNAME'] ?? 'eclo';
    $mqttPassword = $env['MQTT_PASSWORD'] ?? 'Eclo@123';
    $mqttClientId = 'backend-publisher-' . uniqid();

    try {
        $mqtt = new MqttClient($mqttServer, $mqttPort, $mqttClientId);
        $connectionSettings = (new ConnectionSettings)
            ->setUsername($mqttUsername)
            ->setPassword($mqttPassword)
            ->setConnectTimeout(5);
        $mqtt->connect($connectionSettings, true);
        $mqtt->publish($topic, json_encode($payload, JSON_UNESCAPED_UNICODE), 0);
        $mqtt->disconnect();
        error_log("‚úÖ MQTT Publish Success to topic [{$topic}]");
        return true;
    } catch (Exception $e) {
        error_log("‚ùå MQTT Publish Error: " . $e->getMessage());
        return false;
    }
}

/**
 * L∆∞u h√¨nh ·∫£nh t·ª´ chu·ªói base64 v√† tr·∫£ v·ªÅ m·∫£ng ƒë∆∞·ªùng d·∫´n.
 * @return array|null M·∫£ng ch·ª©a ['faces_path', 'photos_path'] ho·∫∑c null n·∫øu th·∫•t b·∫°i.
 */
function save_image_from_base64(?string $picBase64, string $facesUploadPath, string $photosUploadPath, string $prefix, string $uniqueId): ?array
{
    if (empty($picBase64)) {
        error_log("‚ö†Ô∏è [save_image] Chu·ªói base64 r·ªóng.");
        return null;
    }

    // Log m·ªôt ph·∫ßn chu·ªói base64 ƒë·ªÉ debug (gi·ªõi h·∫°n ƒë·ªÉ tr√°nh log qu√° d√†i)
    error_log("üì∑ [save_image] Chu·ªói base64 ƒë·∫ßu v√†o (50 k√Ω t·ª± ƒë·∫ßu): " . substr($picBase64, 0, 50));

    if (!preg_match('/^data:image\/(jpeg|jpg|png);base64,/', $picBase64, $matches)) {
        error_log("‚ö†Ô∏è [save_image] Chu·ªói base64 kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (kh√¥ng ph·∫£i jpeg/jpg/png).");
        return null;
    }

    // Ki·ªÉm tra quy·ªÅn th∆∞ m·ª•c
    if (!is_writable($facesUploadPath)) {
        error_log("‚ö†Ô∏è [save_image] Th∆∞ m·ª•c kh√¥ng th·ªÉ ghi: $facesUploadPath");
        return null;
    }
    if (!is_writable($photosUploadPath)) {
        error_log("‚ö†Ô∏è [save_image] Th∆∞ m·ª•c kh√¥ng th·ªÉ ghi: $photosUploadPath");
        return null;
    }

    try {
        list(, $data) = explode(',', $picBase64);
        $imageData = base64_decode($data);
        if ($imageData === false) {
            error_log("‚ö†Ô∏è [save_image] L·ªói gi·∫£i m√£ base64: Chu·ªói kh√¥ng h·ª£p l·ªá.");
            return null;
        }

        $imageExtension = ($matches[1] === 'jpeg') ? 'jpg' : $matches[1];
        $imageName = $prefix . str_replace('.', '_', $uniqueId) . '_' . time() . '.' . $imageExtension;
        
        $facesFilePath = rtrim($facesUploadPath, '/') . '/' . $imageName;
        $photosFilePath = rtrim($photosUploadPath, '/') . '/' . $imageName;

        error_log("üìÅ [save_image] ƒêang l∆∞u ·∫£nh v√†o: $facesFilePath");

        if (file_put_contents($facesFilePath, $imageData) === false) {
            error_log("‚ö†Ô∏è [save_image] Kh√¥ng th·ªÉ ghi file v√†o: $facesFilePath. L·ªói: " . error_get_last()['message']);
            return null;
        }
        if (!file_exists($facesFilePath)) {
            error_log("‚ö†Ô∏è [save_image] File kh√¥ng t·ªìn t·∫°i sau khi ghi: $facesFilePath");
            return null;
        }
        chmod($facesFilePath, 0644);

        error_log("üìÅ [save_image] ƒêang sao ch√©p ·∫£nh sang: $photosFilePath");

        if (!copy($facesFilePath, $photosFilePath)) {
            error_log("‚ö†Ô∏è [save_image] Kh√¥ng th·ªÉ sao ch√©p file sang: $photosFilePath. L·ªói: " . error_get_last()['message']);
            unlink($facesFilePath);
            return null;
        }
        if (!file_exists($photosFilePath)) {
            error_log("‚ö†Ô∏è [save_image] File kh√¥ng t·ªìn t·∫°i sau khi sao ch√©p: $photosFilePath");
            unlink($facesFilePath);
            return null;
        }
        chmod($photosFilePath, 0644);
        
        error_log("‚úÖ [save_image] ƒê√£ l∆∞u v√† sao ch√©p ·∫£nh th√†nh c√¥ng: $imageName");

        return [
            'faces_path' => 'uploads/faces/' . $imageName,
            'photos_path' => 'uploads/photos/' . $imageName
        ];

    } catch (Exception $e) {
        error_log("‚ö†Ô∏è [save_image] L·ªói ngo·∫°i l·ªá khi x·ª≠ l√Ω ·∫£nh: " . $e->getMessage());
        return null;
    }
}

// --- 1. T·∫¢I C·∫§U H√åNH V√Ä KH·ªûI T·∫†O K·∫æT N·ªêI ---

$envPath = __DIR__ . '/../../.env';
if (!file_exists($envPath)) die("FATAL ERROR: File .env kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y.");
$env = parse_ini_file($envPath);
$publicBaseUrl = rtrim($env['APP_URL'] ?? 'http://localhost', '/');
$facesUploadPath = __DIR__ . '/../../public/uploads/faces/';
$photosUploadPath = __DIR__ . '/../../public/uploads/photos/';

// Log ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c ƒë·ªÉ debug
error_log("üìÅ [INIT] ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c faces: $facesUploadPath");
error_log("üìÅ [INIT] ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c photos: $photosUploadPath");

// Ki·ªÉm tra v√† t·∫°o th∆∞ m·ª•c ngay t·ª´ ƒë·∫ßu ƒë·ªÉ b√°o l·ªói s·ªõm
foreach ([$facesUploadPath, $photosUploadPath] as $path) {
    if (!is_dir($path)) {
        if (!mkdir($path, 0775, true)) {
            die("FATAL ERROR: Kh√¥ng th·ªÉ t·∫°o th∆∞ m·ª•c {$path}.");
        }
        error_log("‚úÖ [INIT] ƒê√£ t·∫°o th∆∞ m·ª•c: $path");
    }
    if (!is_writable($path)) {
        die("FATAL ERROR: Th∆∞ m·ª•c {$path} kh√¥ng c√≥ quy·ªÅn ghi. Vui l√≤ng ki·ªÉm tra quy·ªÅn c·ªßa user ƒëang ch·∫°y script (v√≠ d·ª•: www-data).");
    }
    // Log quy·ªÅn th∆∞ m·ª•c
    error_log("‚úÖ [INIT] Quy·ªÅn th∆∞ m·ª•c {$path}: " . substr(sprintf('%o', fileperms($path)), -4));
}

// K·∫øt n·ªëi Database
try {
    $database = new Medoo([
        'database_type' => $env['DB_CONNECTION'] ?? 'mysql',
        'database_name' => $env['DB_DATABASE'] ?? 'eclo-camera',
        'server'        => $env['DB_HOST'] ?? 'localhost',
        'username'      => $env['DB_USERNAME'] ?? 'root',
        'password'      => $env['DB_PASSWORD'] ?? '',
        'charset'       => $env['DB_CHARSET'] ?? 'utf8mb4',
        'error'         => PDO::ERRMODE_EXCEPTION,
    ]);
    echo "‚úÖ [LISTENER] ƒê√£ k·∫øt n·ªëi Database th√†nh c√¥ng.\n";
} catch (PDOException $e) {
    die("FATAL ERROR: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn database: " . $e->getMessage());
}

// K·∫øt n·ªëi Redis
try {
    $redis = new RedisClient([
        'scheme' => 'tcp',
        'host'   => $env['REDIS_HOST'] ?? '127.0.0.1',
        'port'   => (int)($env['REDIS_PORT'] ?? 6379),
    ]);
    $redis->ping();
    echo "‚úÖ [LISTENER] ƒê√£ k·∫øt n·ªëi Redis th√†nh c√¥ng.\n";
} catch (Exception $e) {
    die("FATAL ERROR: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn Redis: " . $e->getMessage());
}

// --- 2. C·∫§U H√åNH V√Ä CH·∫†Y MQTT LISTENER ---

$server        = $env['MQTT_HOST'] ?? 'mqtt.ellm.io';
$port          = (int)($env['MQTT_PORT_TCP'] ?? 1883);
$clientId      = 'backend-listener-' . uniqid();
$username      = $env['MQTT_USERNAME'] ?? 'eclo';
$password      = $env['MQTT_PASSWORD'] ?? 'Eclo@123';
$wildcardTopic = 'mqtt/face/1018656/+';

$mqtt = new MqttClient($server, $port, $clientId);
$connectionSettings = (new ConnectionSettings)->setUsername($username)->setPassword($password);

try {
    $mqtt->connect($connectionSettings, true);
    
    $mqtt->subscribe($wildcardTopic, function ($topic, $message) use ($database, $redis, $env, $facesUploadPath, $photosUploadPath, $publicBaseUrl) {
        
        echo "üì® [LISTENER] Nh·∫≠n ƒë∆∞·ª£c tin nh·∫Øn tr√™n topic [{$topic}] t·∫°i: " . microtime(true) . "\n";
        $payload = json_decode($message, true);
        if (!$payload || !isset($payload['info'])) {
            error_log("‚ùå [LISTENER] Payload kh√¥ng h·ª£p l·ªá ho·∫∑c thi·∫øu info: " . $message);
            return;
        }
        
        $info = $payload['info'];
        $eventType = basename($topic);
        error_log("üì∏ [DEBUG] Payload cho topic [$topic]: " . json_encode($payload, JSON_UNESCAPED_UNICODE));

        if ($eventType === 'Rec') {
            $imagePaths = save_image_from_base64($info['pic'] ?? null, $facesUploadPath, $photosUploadPath, 'rec_', $info['personId'] ?? uniqid());
            
            $recData = [
                'event_type'  => 'Rec',
                'person_name' => $info['personName'] ?? ($info['persionName'] ?? 'N/A'),
                'person_id'   => $info['personId'] ?? 'N/A',
                'similarity'  => (float)($info['similarity1'] ?? 0),
                'record_id'   => (int)($info['RecordID'] ?? 0),
                'event_time'  => $info['time'] ?? date('Y-m-d H:i:s'),
                'image_path'  => $imagePaths['faces_path'] ?? null,
            ];
            $database->insert('mqtt_messages', $recData);
            echo "‚úÖ [REC] ƒê√£ ghi nh·∫≠n s·ª± ki·ªán cho: " . $recData['person_name'] . "\n";
        }
        
        elseif ($eventType === 'Snap') {
            $picBase64 = $info['pic'] ?? null;
            
            // Chu·∫©n b·ªã d·ªØ li·ªáu c∆° b·∫£n cho mqtt_messages
            $snapData = [
                'event_type'  => 'Snap',
                'person_name' => 'Ng∆∞·ªùi l·∫°',
                'event_time'  => $info['time'] ?? date('Y-m-d H:i:s'),
                'image_path'  => null,
            ];

            if (!$picBase64) {
                error_log("‚ùå [SNAP] Payload thi·∫øu pic base64.");
                $database->insert('mqtt_messages', $snapData);
                echo "‚úÖ [SNAP] ƒê√£ ghi s·ª± ki·ªán Snap thi·∫øu ·∫£nh v√†o logs.\n";
                return;
            }

            // S·ª≠ d·ª•ng kh√≥a ph√¢n t√°n ƒë·ªÉ tr√°nh race condition
            $imageHash = md5($picBase64);
            $redisKey = 'snap_cooldown:' . $imageHash;
            $lockKey = 'snap_lock:' . $imageHash;
            $lockAcquired = $redis->set($lockKey, 1, ['NX', 'EX' => 10]); // Kh√≥a 10 gi√¢y

            if (!$lockAcquired) {
                error_log("‚ÑπÔ∏è [SNAP] B·ªè qua v√¨ tin nh·∫Øn ƒëang ƒë∆∞·ª£c x·ª≠ l√Ω b·ªüi lu·ªìng kh√°c.");
                $database->insert('mqtt_messages', $snapData);
                echo "‚úÖ [SNAP] ƒê√£ ghi s·ª± ki·ªán Snap b·ªã kh√≥a v√†o logs.\n";
                return;
            }

            try {
                // Ki·ªÉm tra Redis kh√≥a ch·ªëng tr√πng l·∫∑p
                if ($redis->exists($redisKey)) {
                    error_log("‚ÑπÔ∏è [SNAP] B·ªè qua v√¨ g∆∞∆°ng m·∫∑t n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω g·∫ßn ƒë√¢y.");
                    $database->insert('mqtt_messages', $snapData);
                    echo "‚úÖ [SNAP] ƒê√£ ghi s·ª± ki·ªán Snap b·ªã kh√≥a v√†o logs.\n";
                    return;
                }

                $newSn = uniqid('NV_');
                $imagePaths = save_image_from_base64($picBase64, $facesUploadPath, $photosUploadPath, 'snap_', $newSn);
                
                if ($imagePaths === null) {
                    error_log("‚ö†Ô∏è [Snap] Kh√¥ng th·ªÉ l∆∞u ·∫£nh. D·ª´ng qu√° tr√¨nh t·ª± ƒë·ªông ƒëƒÉng k√Ω.");
                    $database->insert('mqtt_messages', $snapData);
                    echo "‚úÖ [SNAP] ƒê√£ ghi s·ª± ki·ªán Snap kh√¥ng l∆∞u ƒë∆∞·ª£c ·∫£nh v√†o logs.\n";
                    return;
                }

                // C·∫≠p nh·∫≠t snapData v·ªõi tr·∫°ng th√°i th√†nh c√¥ng
                $snapData['person_name'] = 'Ng∆∞·ªùi l·∫° (Auto-Reg)';
                $snapData['image_path'] = $imagePaths['faces_path'];
                $database->insert('mqtt_messages', $snapData);
                echo "‚úÖ [SNAP] ƒê√£ ghi nh·∫≠n s·ª± ki·ªán Snap v√†o logs.\n";

                $newPersonName = 'Ng∆∞·ªùi l·∫° ' . date('d/m H:i');
                try {
                    $database->insert("employee", [
                        'sn' => $newSn,
                        'person_name' => $newPersonName,
                        'registration_photo' => $imagePaths['photos_path'],
                    ]);
                    echo "‚úÖ [SNAP] ƒê√£ t·ª± ƒë·ªông th√™m nh√¢n vi√™n m·ªõi. SN: {$newSn}\n";

                    $publicImageUrl = $publicBaseUrl . '/' . $imagePaths['photos_path'];
                    $mqttPayload = [
                        "messageId" => uniqid(),
                        "operator" => "EditPerson",
                        "info" => [ "customId" => $newSn, "name" => $newPersonName, "personType" => 0, "picURI" => $publicImageUrl ]
                    ];
                    publishMqttMessage($env, 'mqtt/face/1018656', $mqttPayload);

                    // ƒê·∫∑t kh√≥a Redis sau khi x·ª≠ l√Ω th√†nh c√¥ng
                    $redis->setex($redisKey, 300, 1);

                } catch (Exception $e) {
                    if (file_exists($facesUploadPath . basename($imagePaths['faces_path']))) {
                        unlink($facesUploadPath . basename($imagePaths['faces_path']));
                    }
                    if (file_exists($photosUploadPath . basename($imagePaths['photos_path']))) {
                        unlink($photosUploadPath . basename($imagePaths['photos_path']));
                    }
                    error_log("‚ùå [SNAP] L·ªói DB khi t·ª± ƒë·ªông th√™m nh√¢n vi√™n: " . $e->getMessage());
                }
            } finally {
                // Gi·∫£i ph√≥ng kh√≥a
                $redis->del($lockKey);
            }
        }
    }, 0);

    echo "‚úÖ [LISTENER] K·∫øt n·ªëi MQTT th√†nh c√¥ng. ƒêang l·∫Øng nghe tr√™n topic: {$wildcardTopic}\n";
    $mqtt->loop(true);

} catch (Exception $e) {
    die("FATAL ERROR: Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn MQTT Broker: " . $e->getMessage());
}